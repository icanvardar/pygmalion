use logos::Logos;

#[derive(Logos, Debug, PartialEq)]
pub enum Token {
    #[regex(
        r"after|alias|apply|auto|byte|case|copyof|default|define|final|implements|in|inline|let|macro|match|mutable|null|of|partial|promise|reference|relocatable|sealed|sizeof|static|supports|switch|typedef|typeof|var",
        |lex| lex.slice().to_string()
    )]
    ReservedKeyword(String),
    #[token("abstract")]
    Abstract,
    #[token("address")]
    Address,
    #[token("anonymous")]
    Anonymous,
    #[token("as")]
    As,
    #[token("assembly")]
    Assembly,
    #[token("bool")]
    Bool,
    #[token("break")]
    Break,
    #[token("bytes")]
    Bytes,
    #[token("calldata")]
    Calldata,
    #[token("catch")]
    Catch,
    #[token("constant")]
    Constant,
    #[token("constructor")]
    Constructor,
    #[token("continue")]
    Continue,
    #[token("contract")]
    Contract,
    #[token("delete")]
    Delete,
    #[token("do")]
    Do,
    #[token("else")]
    Else,
    #[token("emit")]
    Emit,
    #[token("enum")]
    Enum,
    #[token("event")]
    Event,
    #[token("external")]
    External,
    #[token("fallback")]
    Fallback,
    #[token("false")]
    False,
    #[token("fixed")]
    Fixed,
    #[regex(r"fixed[1-9][0-9]*x[1-9][0-9]*")]
    FixedWithSize,
    #[regex(r"bytes[1-9]|bytes[1-2][0-9]|bytes3[0-2]")]
    FixedBytes,
    #[token("for")]
    For,
    #[token("function")]
    Function,
    #[token("hex")]
    Hex,
    #[token("if")]
    If,
    #[token("immutable")]
    Immutable,
    #[token("import")]
    Import,
    #[token("indexed")]
    Indexed,
    #[token("interface")]
    Interface,
    #[token("internal")]
    Internal,
    #[token("is")]
    Is,
    #[token("library")]
    Library,
    #[token("mapping")]
    Mapping,
    #[token("memory")]
    Memory,
    #[token("modifier")]
    Modifier,
    #[token("new")]
    New,
    #[regex(r"wei|gwei|ether|seconds|minutes|hours|days|weeks|years")]
    SubDenomination,
    #[token("override")]
    Override,
    #[token("payable")]
    Payable,
    #[token("pragma")]
    Pragma,
    #[token("private")]
    Private,
    #[token("public")]
    Public,
    #[token("pure")]
    Pure,
    #[token("receive")]
    Receive,
    #[token("return")]
    Return,
    #[token("returns")]
    Returns,
    #[regex(r"int|int8|int16|int24|int32|int40|int48|int56|int64|int72|int80|int88|int96|int104|int112|int120|int128|int136|int144|int152|int160|int168|int176|int184|int192|int200|int208|int216|int224|int232|int240|int248|int256")]
    SignedIntegerType,
    #[token("storage")]
    Storage,
    #[token("string")]
    String,
    #[token("struct")]
    Struct,
    #[token("true")]
    True,
    #[token("try")]
    Try,
    #[token("type")]
    Type,
    #[token("ufixed")]
    Ufixed,
    #[regex(r"ufixed[1-9][0-9]*x[1-9][0-9]*")]
    UfixedWithSize,
    #[token("unchecked")]
    Unchecked,
    #[token("unicode")]
    Unicode,
    #[regex(r"uint|uint8|uint16|uint24|uint32|uint40|uint48|uint56|uint64|uint72|uint80|uint88|uint96|uint104|uint112|uint120|uint128|uint136|uint144|uint152|uint160|uint168|uint176|uint184|uint192|uint200|uint208|uint216|uint224|uint232|uint240|uint248|uint256")]
    UnsignedIntegerType,
    #[token("using")]
    Using,
    #[token("view")]
    View,
    #[token("virtual")]
    Virtual,
    #[token("while")]
    While,

    #[token("(")]
    LParen,
    #[token(")")]
    RParen,
    #[token("[")]
    LBrack,
    #[token("]")]
    RBrack,
    #[token("{")]
    LBrace,
    #[token("}")]
    RBrace,
    #[token(":")]
    Colon,
    #[token(";")]
    Semicolon,
    #[token(".")]
    Period,
    #[token("?")]
    Conditional,
    #[token("=>")]
    DoubleArrow,
    #[token("->")]
    RightArrow,

    #[token("=")]
    Assign,
    #[token("|=")]
    AssignBitOr,
    #[token("^=")]
    AssignBitXor,
    #[token("&=")]
    AssignBitAnd,
    #[token("<<=")]
    AssignShl,
    #[token(">>=")]
    AssignSar,
    #[token(">>>=")]
    AssignShr,
    #[token("+=")]
    AssignAdd,
    #[token("-=")]
    AssignSub,
    #[token("*=")]
    AssignMul,
    #[token("/=")]
    AssignDiv,
    #[token("%=")]
    AssignMod,

    #[token(",")]
    Comma,
    #[token("||")]
    Or,
    #[token("&&")]
    And,
    #[token("|")]
    BitOr,
    #[token("^")]
    BitXor,
    #[token("&")]
    BitAnd,
    #[token("<<")]
    Shl,
    #[token(">>")]
    Sar,
    #[token(">>>")]
    Shr,
    #[token("+")]
    Add,
    #[token("-")]
    Sub,
    #[token("*")]
    Mul,
    #[token("/")]
    Div,
    #[token("%")]
    Mod,
    #[token("**")]
    Exp,

    #[token("==")]
    Equal,
    #[token("!=")]
    NotEqual,
    #[token("<")]
    LessThan,
    #[token(">")]
    GreaterThan,
    #[token("<=")]
    LessThanOrEqual,
    #[token(">=")]
    GreaterThanOrEqual,
    #[token("!")]
    Not,
    #[token("~")]
    BitNot,
    #[token("++")]
    Inc,
    #[token("--")]
    Dec,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let mut lex = Token::lexer("after alias apply");

        assert_eq!(
            lex.next(),
            Some(Ok(Token::ReservedKeyword("after".to_string())))
        )
    }
}
